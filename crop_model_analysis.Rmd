---
title: "Eco-cultural niches and the spread of farming"
author: "Nick Gauthier"
date: "Last updated: `r format(Sys.time(), '%d %B, %Y')`"
bibliography: bibliography.bibtex
output: 
  html_document: 
    fig_caption: yes
    highlight: zenburn
    keep_md: yes
    theme: flatly
    toc: yes
---

## Setup
Load necessary packages.
```{r messages = F}
library(raster) # for processing of raster maps
library(tidyverse) # for data cleaning and plotting
library(mgcv) # for fitting generalized additive model 
library(gdistance) # for least cost path calculations
library(viridis) # for pretty colors
library(qgam) # for quantile regression
library(gganimate) # for animated plots
# if gganimate is not installed, run the next line:
# devtools::install_github('dgrtwo/gganimate')
# devtools::install_github("gavinsimpson/schoenberg")
library(schoenberg)
```

Import the database of 14C dates from neolithic sites.
```{r message = F}
dates <- read_csv('data/cs_dates_4_grass.csv') %>%
  filter(Long != 0) %>% # get rid of erroneous entry
  select(Site_Name, Long, Lat, Cal.BC, Cal.BC.SD) # select just the variables we'll need
```


```{r echo = }
load('data//med_region_gg.rda')

ggplot(dates, aes(Long, Lat)) +
  geom_point(aes(color = Cal.BC)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_color_distiller(palette = 'RdYlBu') +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupation') +
  theme_void()
```

## Least cost distance modeling
First let's use the **gdistance** package to calculate how far all the sites in our database are from Jericho (which we use as the "first" site).

Define our study area as the supra-mediterranean region.
```{r}
bbox <- extent(-9.9, 45, 29.8, 50)
```

Find the location of Jericho to use as a starting point. 
```{r}
jericho <- dates %>%
  filter(Site_Name == 'Jericho') %>%
  select(Long:Lat) %>%
  as.matrix
```

Import map distinguishing land and water areas ([source](http://worldgrids.org/doku.php/wiki:dicgsh1)).
```{r}
distance_coast <- raster('data/DICGSH1a.tif') %>% # import the map
  crop(bbox) # crop to the study area

euc <-  distance_coast %>%
  reclassify(c(-Inf, Inf, 1)) # pure water to 0, all else to 1

land_mask <- distance_coast %>%
  reclassify(c(0, Inf, NA, -Inf, 0, 1)) # pure water to 0, all else to 1

land_sea <- distance_coast %>%
  reclassify(c(40, Inf, NA, -Inf, 40, 1)) # pure water to 0, all else to 1
```

```{r echo = F}
land_sea %>%
  as.data.frame(xy = T, na.rm = T) %>%
  ggplot(aes(x, y, fill = layer)) +
    geom_raster() +
    geom_raster(data = as.data.frame(land_mask, xy = T, na.rm = T), fill = 'red') +
    ggtitle('Land-sea mask', 'Source: Worldgrids.org') +
    coord_quickmap() +
    theme_void()
```

```{r}
con_euc_c <- transition(euc, mean, 16, symm = T) %>% # knight's move
  geoCorrection(type = 'c') # correct inter cell distances for latlon distortion

con_euc_r <- transition(euc, mean, 16, symm = T) %>% # now for random walks
  geoCorrection(type = 'r')
```

Generate a simple conductance matrix, where all land-land connections are set to 1 and all land-sea or sea-sea connections are set to 0.
```{r}
con_land_c <- transition(land_mask, min, 16, symm = T) %>%
  geoCorrection(type = 'c')

con_land_r <- transition(land_mask, min, 16, symm = T) %>% 
  geoCorrection(type = 'r') 
```

Repeat, allowing connections across less than 40km of sea.
```{r}
con_landsea_c <- transition(land_sea, min, 16, symm = T) %>% 
  geoCorrection(type = 'c')

con_landsea_r <- transition(land_sea, min, 16, symm = T) %>% 
  geoCorrection(type = 'r')
```

```{r}
accumulation <- list(con_euc_c, con_land_c, con_landsea_c) %>%
  map(accCost, fromCoords = jericho) %>%
  brick
```


```{r echo = F}
accumulation %>%
  mask(land_mask) %>%
  as.data.frame(xy = T, na.rm =T) %>%
  rename(euc = layer.1, land = layer.2, landsea = layer.3) %>%
  gather(type, cost, 3:5) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = cost)) +
  facet_wrap(~type, nrow = 3) +
  scale_fill_viridis(direction = -1) +
  coord_quickmap() +
  theme_void()
```

Add the results to the sites data. (Why does raster:extract result in some na's and infs? something to do with the land sea boundary?)
```{r}
costs <- dates %>%
  select(Long:Lat) %>%
  as.matrix %>%
  raster::extract(accumulation, ., df = T) %>%
  rename(euc = layer.1, land = layer.2, landsea = layer.3, month_land = layer.4, month_sea = layer.5) %>%
  cbind(dates, .) %>%
  select(-ID) %>%
  gather(type, cost, euc:month_sea) %>%
  nest(-type) %>%
  mutate(data = map(data, ~filter(., is.finite(cost)))) %>%
  mutate(data = map(data, ~filter(., cost < 3.4e10))) # shouldnt have to do this!
```


```{r}
quantile_gam <- function(df){
  qgam(list(
    Cal.BC ~ s(cost, bs = 'cr'), 
           ~ s(cost, bs = 'cr')), 
    data = df,
    qu = 0.9)
}

make_preds <- function(x){
  predict(x, type = 'response', se = T) %>%
  map(~.[,1]) %>%
  bind_cols %>%
  mutate(upper = fit + 2 * se.fit,
         lower = fit - 2 * se.fit)
}
```

```{r}
fits <- costs %>%
  mutate(mod = map(data, quantile_gam),
         aic = map_dbl(mod, 'aic'),
         preds = map(mod, make_preds))
fits
```


```{r}
plot_results <- function(x){
  print(ggplot(x, aes(cost, Cal.BC)) +
  geom_pointrange(aes(ymin = Cal.BC - Cal.BC.SD, 
                      ymax = Cal.BC + Cal.BC.SD,  
                      alpha = (1 / Cal.BC.SD) ^ 2), fatten = 2) +
  geom_line(aes(y = fit), color = 'red') +
  geom_line(aes(y = lower), linetype = 2, color = 'red') +
  geom_line(aes(y = upper), linetype = 2, color = 'red') +
  xlim(0, 5.5e6) +
  theme_bw())
}


map2(fits$data, fits$preds, bind_cols) %>%
  walk(plot_results)
```

```{r eval=FALSE, include=FALSE}
mod <- gam(Cal.BC ~ s(cost, bs = 'cr'), 
            data = costs$data[[3]],
            weights = (1/costs$data[[3]]$Cal.BC.SD)^2)
mod2<- gam(Cal.BC ~ s(cost, bs = 'cr'), 
            data = costs)
mod3 <- gam(Cal.BC ~ s(cost, bs = 'cr'), 
            data = costs,
            weights = (1/costs$Cal.BC.SD)^2 / mean((1/costs$Cal.BC.SD)^2))
plot(mod);plot(mod2); plot(mod3)
```

```{r}
preds %>%
  mutate(resid = Cal.BC - fit) %>%
ggplot(aes(Long, Lat)) +
  geom_point(aes(color = resid), size = 3) +
  geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_color_distiller(palette = 'RdYlBu', limits = c(-2500, 2500)) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupation') +
  theme_void()
```
Now add in seas with a distance decay function.



```{r}
library(tidygraph)
library(ggraph)

commuteDistance(con_landsea_r, pts)
net <- as_tbl_graph(out) %>%
  mutate(date = dat$Cal.BC, x = dat$Long, y = dat$Lat, resids = mod1$residuals) %>%
  activate(edges) %>%
  mutate(time_diff = .N()$date[from] - .N()$date[to]) %>%
  mutate(med_date = (.N()$date[from] + .N()$date[to]) / 2)


net %>%
  filter(time_diff > 0 & time_diff <= 65) %>%
  filter(weight <= 600000) %>%
ggraph() +
  geom_edge_fan(alpha = .2) +
  geom_node_point(aes(color = date)) +
  scale_color_distiller(palette = 'Spectral', direction = -1) +
  theme_void() +
  geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50))
```



```{r}
yields_rast <- list.files('data/paleoD_10nov16/paleoD3p1_monthlyyieldonly/whemmer/', 
                      pattern = '*ensemble*',
                      full.names = T) %>%
  map(raster) %>%
  brick %>%
  .[[c(1, 5:12, 2:4)]] %>%
  reclassify(c(-Inf, 0, 0, NA, NA, 0)) %>%
  mask(., crop(land_mask, extent(.))) %>%
  `names<-`(month.name) %>%
  `projection<-`('+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0')
```

```{r}
yields <- yields_rast %>% as.data.frame(xy = T, na.rm = T) %>%
  gather(month, yield, 3:14) %>%
  mutate(month = factor(month, levels = month.name),
         season = case_when(month %in% month.name[c(12, 1, 2)] ~ 'Winter', 
                            month %in% month.name[3:5] ~ 'Spring',
                            month %in% month.name[6:8] ~ 'Summer',
                            month %in% month.name[9:11] ~ 'Fall'),
         season = factor(season, levels = c('Winter', 'Spring', 'Summer', 'Fall')))
```

```{r echo = F}
ggplot(yields, aes(x, y, fill = yield)) +
  geom_raster() +
  scale_fill_viridis() +
  facet_wrap(~month) +
  coord_quickmap() +
  theme_void()
```

```{r echo = F}
yields %>%
  group_by(x, y, season) %>%
  filter(yield == max(yield)) %>%
  filter(yield > 0) %>%
ggplot(aes(x, y, fill = yield)) +
  geom_raster() +
  scale_fill_viridis() +
  facet_wrap(~season) +
  coord_quickmap() +
  theme_void()
```


```{r echo = F}
yields %>%
  group_by(x, y) %>%
  filter(yield == max(yield)) %>%
  filter(yield > 0) %>%
ggplot(aes(x, y)) +
  geom_raster(aes(fill = season, alpha = yield)) +
  geom_point(data = dates, aes(Long, Lat)) +
  geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_fill_manual(values = c('#2b83ba', '#abdda4', '#d7191c', '#fdae61')) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  theme_void()
```


```{r}
dat2 %>%
  mutate(arrival = if_else(residuals <= 0, 'Late', 'Early')) %>%
ggplot(aes(Long, Lat)) +
  geom_raster(data = best.month, aes(x, y, fill = Month, alpha = Yield)) +
  geom_point(aes(color = arrival)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_fill_manual(values = c('#2b83ba', '#abdda4', '#d7191c', '#fdae61')) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupations over wheat planting season and yield') +
  theme_void()
```



```{r}
vid <- ggplot(dat, aes(Long, Lat)) +
  geom_raster(data = best.month, aes(x, y, fill = Month, alpha = Yield)) +
  geom_point(aes(frame = Cal.BC * -1, cumulative = T)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_fill_manual(values = c('#2b83ba', '#abdda4', '#d7191c', '#fdae61')) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupations over wheat planting season and yield') +
  theme_void()

gganimate(vid, filename = 'neo_spread.mp4', saver = 'mp4')
```

van etten reporduction
```{r}
decay <- function(x, p){
	tm <- transitionMatrix(x)
	tm@x[tm@x>0.1] <- (2^-(tm@x[tm@x>0.1]/p))
	tm@x <- tm@x/max(tm@x)
	transitionMatrix(x) <- tm
	return(x)
}

plot(distance_coast)

#Geographic data: land/sea
landT <- transition(land_mask, min, directions = 8)
landT <- normalize(landT, method = 'symm')
index1 <- adjacency(seaMask, which(values(seaMask) == 1), which(values(seaMask) == 1), directions=8)

landsea <- land_mask
landsea <- setValues(landsea, rep(1,times=ncell(landsea)))
allT <- transition(landsea, max, directions = 8)
correctionArch <- geoCorrection(allT, type="c", multpl=TRUE)
correctionGen <- geoCorrection(allT, type="r", multpl=TRUE)

seaCost <- mask(distance_coast, land_mask, inverse = T)
plot(seaCost);plot(raster(seaT))
seaT <- transition(seaCost, mean, directions = 8)
plot(raster(decay(seaT, 20) + landT))

index2 <- adjacency(seaCost, which(values(seaCost) > 0), 1:ncell(seaCost), directions=8)
```

```{r}
expand.grid(difference = seq(0,6,.1), weight = seq(.1,1,.1)) %>%
  mutate(test = exp(- weight * difference^2)) %>%
  ggplot(aes(difference, test, group = weight, color = weight)) +
  geom_line()
plot(1 / (100 + 0:6))


1/0
```

```{r}
month_fun <- function(x){
  dist <- 6 - abs(abs(x[1] - x[2]) - 6)
  return(exp(- 1 * dist^2))
}
month_fun(c(1,NA))
sea_decay <- distance_coast %>%
  mask(land_mask, inverse = T) %>%
  crop(extent(yields_rast)) %>%
  transition(mean, directions = 16) %>%
  decay(60)

plot(raster(sea_decay))
plot(which.max(yields_rast))
month_sea <- (transition(which.max(yields_rast), month_fun, direction = 16) + sea_decay) %>%
  geoCorrection(type = 'c')
month_only <- (transition(which.max(yields_rast), month_fun, direction = 16)) %>%
  geoCorrection(type = 'c')
plot(raster(month_only));plot(raster(month_sea))
```

```{r}
accumulation <- list(con_euc_c, con_land_c, con_landsea_c, month_only, month_sea) %>%
  map(accCost, fromCoords = jericho) %>%
  map(crop, y = extent(yields_rast)) %>%
  brick
```


```{r echo = F}
plot(accumulation)
accumulation %>%
  mask(crop(land_mask, extent(yields_rast))) %>%
  as.data.frame(xy = T, na.rm =T) %>%
  rename(euc = layer.1, land = layer.2, landsea = layer.3, month_only = layer.4, month_sea = layer.5) %>%
  gather(type, cost, 3:7) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = cost)) +
  facet_wrap(~type, nrow = 3) +
  scale_fill_viridis(direction = -1) +
  coord_quickmap() +
  theme_void()
```
```


```{r}
plot(landsea)
```
```{r}
constr <- function(pv) 
{
	if(seaMask[cellFromXY(seaMask,SpatialPoints(t(as.matrix(c(pv[1],pv[2])))))] == 0) {con <- -1}
	else{con <- 1}
	return(con)
}

createTransition <- function(pv)
{
	pv[4] <- (1.1 ^ pv[4])/10
	seaTi <- decay(seaT,pv[3])
	seaTr <- normalize(seaTi , symm = TRUE) #normalize(seaTi, method="symm")
	Trt <- seaTr * pv[4] + landT 
	Trt <- Trt * correctionArch
	return(Trt)
}

wghtsArch <- rep(1, times=length(coord[,1]))
for (i in 1:length(coord[,1]))
{
	dists <- pointDistance(as.vector(coord[i,]),coord,type='GreatCircle')
	wghtsArch[i] <- 1/(sum(dists<100000))
}
```


```{r}
#############################    ANALYSIS  ########################################

#Calculate null models quantile regression
rho0Arch <- rq(Calibrated_median ~ 1, tau=.8, data=dates, weights=wghtsArch)$rho
rho0Hz <- rq(Hz ~ 1, tau=.2)$rho

#SETTINGS
xmin <- -110
xmax <- -80
ymin <- 8
ymax <- 25

#Get solutions
sol1 <- nsga2(RR, 4, 2,
	generations=60, 
	popsize=200,
	lower.bounds=c(xmin,ymin, 1000, -100), 
	upper.bounds=c(xmax,ymax, 200000, 100), 
	constraints=constr
	)

#Format and store solutions
sol <- cbind(sol1$par,sol1$value,sol1$pareto.optimal)
sol <- sol[sol[,7] == 1,]
sol <- unique(sol)
sol <- sol[order(sol[,5]),]
sol[,5] <- 1 - sol[,5]
sol[,6] <- 1 - sol[,6]
write.csv(sol,"ParetoOptimalSolutions2.csv")

#Read solution into memory and select representative solutions
sol <- read.csv("ParetoOptimalSolutions.csv", row.names=1)
selectSol <- as.numeric(rownames(pam(sol[,1:2], 8, metric="euclidean")$medoids))
selectSol <- c(selectSol,145)

#Table 1
Table1 <- sol[selectSol,1:6]
Table1[,4] <- (1.1 ^ Table1[,4])/10
colnames(Table1) <- c("Longitude","Latitude","p2","p1","R1 Arch","R1 Gene")
rownames(Table1) <- LETTERS[1:9]

#Look at representative solutions for different values of theta
theta <- c(0.01, 0.1, 0.5, 1, 1.5, 2)

for(i in c(6,9))#length(selectSol))
{
	x <- selectSol[i]
	pv <- unlist(sol[x,1:6])
	origin <- SpatialPoints(t(as.matrix(pv[1:2])))
	Tr <- createTransition(pv)
	for(th in 2:6) 
	{
		PI <- pathInc(Tr, origin, ssrSP, type=c("divergent","joint"), theta = theta[th])
		div <- PI$divergent
		joint <- PI$joint
		dataGenGeo <- as.data.frame(cbind(joint, div, geoDist))
		write.csv(dataGenGeo,paste("dataGenGeoT", LETTERS[i], "theta=", theta[th], sep=""))
	}
}

resultR2 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultSign1 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultSign2 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultCoeff1 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultCoeff2 <- matrix(nrow=length(theta),ncol=length(selectSol))

for(i in 1:length(selectSol))
{
	for(th in 1:length(theta))
	{
		dataGG <- read.csv(paste("dataGenGeoT", LETTERS[i], "theta=", theta[th], sep=""))
		dataGG <- as.data.frame(cbind(ssrDist,dataGG))
		result <- permReg(ssrDist ~ joint + div, dat=dataGG, perms = 999)
		resultR2[th,i] <- result$r.square
		resultSign1[th,i] <- result$significance.terms[1]
		resultSign2[th,i] <- result$significance.terms[2]
		resultCoeff1[th,i] <- result$coeff[2]
		resultCoeff2[th,i] <- result$coeff[3]		
	}
}

#Table 2
resultR2 <- round(resultR2, digits=3)
rownames(resultR2) <- theta
colnames(resultR2) <- LETTERS[1:9]

#############################    END ANALYSIS  #
```

