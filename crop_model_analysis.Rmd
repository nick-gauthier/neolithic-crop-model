---
title: "Eco-cultural niches and the spread of farming"
author: "Nick Gauthier"
date: "Last updated: `r format(Sys.time(), '%d %B, %Y')`"
bibliography: bibliography.bibtex
output: 
  html_document: 
    fig_caption: yes
    highlight: zenburn
    keep_md: yes
    theme: flatly
    toc: yes
---

## Setup
Load necessary packages.
```{r messages = F}
library(raster) # for processing of raster maps
library(tidyverse) # for data cleaning and plotting
library(mgcv) # for fitting generalized additive model 
library(gdistance) # for least cost path calculations
library(viridis) # for pretty colors
library(qgam) # for quantile regression
library(gganimate) # for animated plots
# if gganimate is not installed, run the next line:
# devtools::install_github('dgrtwo/gganimate')
#devtools::install_github("gavinsimpson/schoenberg")
library(schoenberg)
```

Import the database of 14C dates from neolithic sites.
```{r message = F}
dates <- read_csv('data/cs_dates_4_grass.csv') %>%
  filter(Long != 0) %>% # get rid of erroneous entry
  select(Site_Name, Long, Lat, Cal.BC, Cal.BC.SD) # select just the variables we'll need
```


```{r echo = }
load('data//med_region_gg.rda')

ggplot(dates, aes(Long, Lat)) +
  geom_point(aes(color = Cal.BC)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_color_distiller(palette = 'RdYlBu') +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupation') +
  theme_void()
```

## Least cost distance modeling
First let's use the **gdistance** package to calculate how far all the sites in our database are from Jericho (which we use as the "first" site).

Define our study area as the supra-mediterranean region.
```{r}
bbox <- extent(-9.9, 45, 29.8, 50)
```

Find the location of Jericho to use as a starting point. 
```{r}
jericho <- dates %>%
  filter(Site_Name == 'Jericho') %>%
  select(Long:Lat) %>%
  as.matrix
```

Import map distinguishing land and water areas ([source](http://worldgrids.org/doku.php/wiki:dicgsh1)).
```{r}
distance_coast <- raster('data/DICGSH1a.tif') %>% # import the map
  crop(bbox) # crop to the study area

euc <-  distance_coast %>%
  reclassify(c(-Inf, Inf, 1)) # pure water to 0, all else to 1

land_mask <- distance_coast %>%
  reclassify(c(0, Inf, NA, -Inf, 0, 1)) # pure water to 0, all else to 1

land_sea <- distance_coast %>%
  reclassify(c(40, Inf, NA, -Inf, 40, 1)) # pure water to 0, all else to 1
```

```{r echo = F}
land_sea %>%
  as.data.frame(xy = T, na.rm = T) %>%
  ggplot(aes(x, y, fill = layer)) +
    geom_raster() +
    geom_raster(data = as.data.frame(land_mask, xy = T, na.rm = T), fill = 'red') +
    ggtitle('Land-sea mask', 'Source: Worldgrids.org') +
    coord_quickmap() +
    theme_void()
```

```{r}
con_euc_c <- transition(euc, mean, 16, symm = T) %>% # knight's move
  geoCorrection(type = 'c') # correct inter cell distances for latlon distortion

con_euc_r <- transition(euc, mean, 16, symm = T) %>% # now for random walks
  geoCorrection(type = 'r')
```

Generate a simple conductance matrix, where all land-land connections are set to 1 and all land-sea or sea-sea connections are set to 0.
```{r}
con_land_c <- transition(land_mask, mean, 16, symm = T) %>%
  geoCorrection(type = 'c')

con_land_r <- transition(land_mask, mean, 16, symm = T) %>% 
  geoCorrection(type = 'r') 
```

Repeat, allowing connections across less than 40km of sea.
```{r}
con_landsea_c <- transition(land_sea, mean, 16, symm = T) %>% 
  geoCorrection(type = 'c')

con_landsea_r <- transition(land_sea, mean, 16, symm = T) %>% 
  geoCorrection(type = 'r')
```

```{r}
accumulation <- list(con_euc_c, con_land_c, con_landsea_c) %>%
  map(accCost, fromCoords = jericho) %>%
  brick
```


```{r echo = F}
accumulation %>%
  mask(land_mask) %>%
  as.data.frame(xy = T, na.rm =T) %>%
  rename(euc = layer.1, land = layer.2, landsea = layer.3) %>%
  gather(type, cost, 3:5) %>%
  ggplot(aes(x, y)) +
  geom_raster(aes(fill = cost)) +
  facet_wrap(~type, nrow = 3) +
  scale_fill_viridis(direction = -1) +
  coord_quickmap() +
  theme_void()
```

Add the results to the sites data. (Why does raster:extract result in some na's and infs? something to do with the land sea boundary?)
```{r}
costs <- dates %>%
  select(Long:Lat) %>%
  as.matrix %>%
  raster::extract(accumulation, ., df = T) %>%
  rename(euc = layer.1, land = layer.2, landsea = layer.3) %>%
  cbind(dates, .) %>%
  select(-ID) %>%
  gather(type, cost, euc:landsea) %>%
  nest(-type) %>%
  mutate(data = map(data, ~filter(., is.finite(cost))))
```


```{r}
library(broom)
library(modelr)
quantile_gam <- function(df){
  qgam(list(
    Cal.BC ~ s(cost, bs = 'cr'), 
           ~ s(cost, bs = 'cr')), 
    data = df,
    qu = 0.8)
}
cqcheck(quantile_mod, v = 'cost')
broom::glance(as(quantile_mod, 'gamObject', strict = F))
class(mod)
fits <- costs %>%
  mutate(mod = map(data, quantile_gam),
         aic = map_dbl(mod, 'aic'),
         preds = map(mod, make_preds))
   
make_preds <- function(x){
  predict(x, type = 'response', se = T) %>%
  map(~.[,1]) %>%
  bind_cols %>%
  mutate(upper = fit + 2 * se.fit,
         lower = fit - 2 * se.fit)
}

fits$preds1
```


```{r}
plot_results <- function(x){
  print(ggplot(x, aes(cost, Cal.BC)) +
  geom_pointrange(aes(ymin = Cal.BC - Cal.BC.SD, 
                      ymax = Cal.BC + Cal.BC.SD,  
                      alpha = (1 / Cal.BC.SD) ^ 2), fatten = 2) +
  geom_line(aes(y = fit), color = 'red') +
  geom_line(aes(y = lower), linetype = 2, color = 'red') +
  geom_line(aes(y = upper), linetype = 2, color = 'red') +
  theme_bw())
}


test<- map2(fits$data, fits$preds, bind_cols) %>%
walk(plot_results)


ggplot(preds, aes(cost, Cal.BC)) +
  geom_pointrange(aes(ymin = Cal.BC - Cal.BC.SD, 
                      ymax = Cal.BC + Cal.BC.SD,  
                      alpha = (1 / Cal.BC.SD) ^ 2), fatten = 2) +
  geom_line(aes(y = fit), color = 'red') +
  geom_line(aes(y = lower), linetype = 2, color = 'red') +
  geom_line(aes(y = upper), linetype = 2, color = 'red') +
  theme_bw()
```

```{r eval=FALSE, include=FALSE}
mod <- gam(Cal.BC ~ s(cost, bs = 'cr'), 
            data = costs$data[[3]],
            weights = (1/costs$data[[3]]$Cal.BC.SD)^2)
mod2<- gam(Cal.BC ~ s(cost, bs = 'cr'), 
            data = costs)
mod3 <- gam(Cal.BC ~ s(cost, bs = 'cr'), 
            data = costs,
            weights = (1/costs$Cal.BC.SD)^2 / mean((1/costs$Cal.BC.SD)^2))
plot(mod);plot(mod2); plot(mod3)
```

```{r}
mask(land_sea, land_sea, maskvalue = 0) %>%
  buffer(40) 
preds %>%
  mutate(resid = Cal.BC - fit) %>%
ggplot(aes(Long, Lat)) +
  geom_point(aes(color = resid), size = 3) +
  geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_color_distiller(palette = 'RdYlBu', limits = c(-2500, 2500)) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupation') +
  theme_void()
```
Now add in seas with a distance decay function.



```{r}
library(tidygraph)
library(ggraph)

commuteDistance(con_landsea_r, pts)
net <- as_tbl_graph(out) %>%
  mutate(date = dat$Cal.BC, x = dat$Long, y = dat$Lat, resids = mod1$residuals) %>%
  activate(edges) %>%
  mutate(time_diff = .N()$date[from] - .N()$date[to]) %>%
  mutate(med_date = (.N()$date[from] + .N()$date[to]) / 2)


net %>%
  filter(time_diff > 0 & time_diff <= 65) %>%
  filter(weight <= 600000) %>%
ggraph() +
  geom_edge_fan(alpha = .2) +
  geom_node_point(aes(color = date)) +
  scale_color_distiller(palette = 'Spectral', direction = -1) +
  theme_void() +
  geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50))
```


## Spatiotemporal point pattern analysis


```{r}
best.month <- brick(c(raster('~/Dropbox/crop models/paleoD_10nov16/paleoD_11oct16/best_month_scr_PALEOd__whemmer0RF_269_d0_paleoD__ensemble_mh6k_p0_neolithiccrop__rainfed_yield_mean.asc'),
                      raster('~/Dropbox/crop models/paleoD_10nov16/paleoD_11oct16/best_yield_scr_PALEOd__whemmer0RF_269_d0_paleoD__ensemble_mh6k_p0_neolithiccrop__rainfed_yield_mean.asc'))) %>%
  as.data.frame(xy = T, na.rm = T) %>%
  as_tibble %>%
  rename(Month = best_month_scr_PALEOd__whemmer0RF_269_d0_paleoD__ensemble_mh6k_p0_neolithiccrop__rainfed_yield_mean,
         Yield = best_yield_scr_PALEOd__whemmer0RF_269_d0_paleoD__ensemble_mh6k_p0_neolithiccrop__rainfed_yield_mean) %>%
  mutate(Month = if_else(Month %in% c(12, 1, 2), 'Winter', 
                         if_else(Month %in% 3:5, 'Spring',
                                 if_else(Month %in% 6:8, 'Summer',
                                         if_else(Month %in% 9:11, 'Fall', 'None'))))) %>%
  mutate(Month = factor(Month, c('Winter', 'Spring', 'Summer', 'Fall')))

```
```{r}
ggplot(dates, aes(Long, Lat)) +
  geom_raster(data = best.month, aes(x, y, fill = Month, alpha = Yield)) +
  geom_point(aes(frame = Cal.BC * -1, cumulative = T)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_fill_manual(values = c('#2b83ba', '#abdda4', '#d7191c', '#fdae61')) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  theme_void()
```

```{r}
yields <- list.files('data/paleoD_10nov16/paleoD3p1_monthlyyieldonly/whemmer/', 
                      pattern = '*ensemble*',
                      full.names = T) %>%
  map(raster) %>%
  brick %>%
  .[[c(4:12, 1:3)]] %>%
  reclassify(c(-Inf, 0, 0, NA, NA, 0)) %>%
  mask(., crop(land_mask, extent(.)))
names(yields) <- month.name
```

```{r echo = F}
yields %>%
  as.data.frame(xy = T, na.rm = T) %>%
  gather(month, yield, 3:14) %>%
  mutate(month = factor(month, levels = month.name)) %>%
  ggplot(aes(x, y, fill = yield)) +
  geom_raster() +
  scale_fill_viridis() +
  facet_wrap(~month) +
  coord_quickmap() +
  theme_void()
```


```{r}
dat2 %>%
  mutate(arrival = if_else(residuals <= 0, 'Late', 'Early')) %>%
ggplot(aes(Long, Lat)) +
  geom_raster(data = best.month, aes(x, y, fill = Month, alpha = Yield)) +
  geom_point(aes(color = arrival)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_fill_manual(values = c('#2b83ba', '#abdda4', '#d7191c', '#fdae61')) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupations over wheat planting season and yield') +
  theme_void()
```

```{r}
dat2 %>%
  mutate(arrival = if_else(residuals > -100, 'Early', 'Late')) %>%
ggplot(aes(Long, Lat)) +
  geom_raster(data = winter_yield, aes(x, y, fill = layer)) +
  geom_point(aes(color = residuals)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_color_distiller(palette = 'RdYlBu') +
  scale_fill_viridis() +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupations over wheat planting season and yield') +
  theme_void()
```


```{r}
vid <- ggplot(dat, aes(Long, Lat)) +
  geom_raster(data = best.month, aes(x, y, fill = Month, alpha = Yield)) +
  geom_point(aes(frame = Cal.BC * -1, cumulative = T)) +
    geom_path(data = med_region_gg, aes(long,lat, group = group)) +
  scale_fill_manual(values = c('#2b83ba', '#abdda4', '#d7191c', '#fdae61')) +
  coord_quickmap(xlim = c(-9.9, 45), ylim = c(30, 50)) +
  labs(title = 'Neolithic spread', subtitle = 'Initial site occupations over wheat planting season and yield') +
  theme_void()

gganimate(vid, filename = 'neo_spread.mp4', saver = 'mp4')
```

van etten reporduction
```{r}
decay <- function(x,p)
{
	tm <- transitionMatrix(x)
	tm@x[tm@x>0.1] <- (2^-(tm@x[tm@x>0.1]/p))
	tm@x <- tm@x/max(tm@x)
	transitionMatrix(x) <- tm
	return(x)
}

Rho <- function(residl, Tau) {residl * (Tau - (residl < 0))  }	

constr <- function(pv) 
{
	if(seaMask[cellFromXY(seaMask,SpatialPoints(t(as.matrix(c(pv[1],pv[2])))))] == 0) {con <- -1}
	else{con <- 1}
	return(con)
}

createTransition <- function(pv)
{
	pv[4] <- (1.1 ^ pv[4])/10
	seaTi <- decay(seaT,pv[3])
	seaTr <- normalize(seaTi , symm = TRUE) #normalize(seaTi, method="symm")
	Trt <- seaTr * pv[4] + landT 
	Trt <- Trt * correctionArch
	return(Trt)
}

RR <- function(pv)
{
	R <- c(0,0)
	cat("xy:", pv[1:2], ", parameters:", pv[3:4])
	origin <- SpatialPoints(t(as.matrix(c(pv[1],pv[2]))))
	if(seaMask[cellFromXY(seaMask,origin)] == 1)
	{
		Tr <- createTransition(pv)
		cdm <- accCost(Tr,origin)
		cdm1 <- values(cdm)[cellArchaeo]
		cdm2 <- values(cdm)[cellSSR]
		if(all(!(cdm1 %in% c(-Inf, Inf)),!is.na(cdm1)))
		{
			tdata <- cbind(dates,cdm1)
			outcome1 <- try(rq(Calibrated_median ~ cdm1, tau=.8, data=tdata, weights=wghtsArch))
			outcome2 <- try(rq(Hz ~ cdm2, tau=.2))
			if(class(outcome1) == "rq" & class(outcome2) == "rq")
			{
				slope1 <- coefficients(outcome1)[2]
				if(slope1>0){}
				else {R[1] <- 1- outcome1$rho / rho0Arch}
				slope2 <- coefficients(outcome2)[2]
				if(slope2>0){}
				else {R[2] <- 1 - outcome2$rho / rho0Hz}
				cat(", R:", R, "\n")
			} else{cat("\nrq failed\n")}
		} else{cat("\nNA and/or Inf\n")}
	} else{cat("\nsea\n")}
	return(1-R) 
}

wghtsArch <- rep(1, times=length(coord[,1]))
for (i in 1:length(coord[,1]))
{
	dists <- pointDistance(as.vector(coord[i,]),coord,type='GreatCircle')
	wghtsArch[i] <- 1/(sum(dists<100000))
}


#Geographic data: land/sea
seaMask <- raster(landlake, values=TRUE)
projection(seaMask) <- "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
landT <- TransitionFromRaster(seaMask,transitionFunction="min",directions=8)
landT <- normalize(landT, symm = TRUE)
index1 <- adjacency(seaMask, which(values(seaMask) == 1), which(values(seaMask) == 1), directions=8)

landsea <- seaMask
landsea <- setValues(landsea, rep(1,times=ncell(landsea)))
allT <- TransitionFromRaster(landsea, transitionFunction="max", directions=8)
correctionArch <- geoCorrection(allT, type="c", multpl=TRUE)
correctionGen <- geoCorrection(allT, type="r", multpl=TRUE)

seaMaskNA <- seaMask
seaMaskNA[which(values(seaMask) == 0)] <- NA
seaCost <- distance(seaMaskNA)
seaT <- transition(seaCost,transitionFunction="mean",directions=8)
index2 <- adjacency(seaCost, which(values(seaCost) > 0), 1:ncell(seaCost), directions=8)

#Get cell values
cellArchaeo <- cellFromXY(seaMask, datesSP)
cellSSR <- cellFromXY(seaMask, ssrSP)


#############################    ANALYSIS  ########################################

#Calculate null models quantile regression
rho0Arch <- rq(Calibrated_median ~ 1, tau=.8, data=dates, weights=wghtsArch)$rho
rho0Hz <- rq(Hz ~ 1, tau=.2)$rho

#SETTINGS
xmin <- -110
xmax <- -80
ymin <- 8
ymax <- 25

#Get solutions
sol1 <- nsga2(RR, 4, 2,
	generations=60, 
	popsize=200,
	lower.bounds=c(xmin,ymin, 1000, -100), 
	upper.bounds=c(xmax,ymax, 200000, 100), 
	constraints=constr
	)

#Format and store solutions
sol <- cbind(sol1$par,sol1$value,sol1$pareto.optimal)
sol <- sol[sol[,7] == 1,]
sol <- unique(sol)
sol <- sol[order(sol[,5]),]
sol[,5] <- 1 - sol[,5]
sol[,6] <- 1 - sol[,6]
write.csv(sol,"ParetoOptimalSolutions2.csv")

#Read solution into memory and select representative solutions
sol <- read.csv("ParetoOptimalSolutions.csv", row.names=1)
selectSol <- as.numeric(rownames(pam(sol[,1:2], 8, metric="euclidean")$medoids))
selectSol <- c(selectSol,145)

#Table 1
Table1 <- sol[selectSol,1:6]
Table1[,4] <- (1.1 ^ Table1[,4])/10
colnames(Table1) <- c("Longitude","Latitude","p2","p1","R1 Arch","R1 Gene")
rownames(Table1) <- LETTERS[1:9]

#Look at representative solutions for different values of theta
theta <- c(0.01, 0.1, 0.5, 1, 1.5, 2)

for(i in c(6,9))#length(selectSol))
{
	x <- selectSol[i]
	pv <- unlist(sol[x,1:6])
	origin <- SpatialPoints(t(as.matrix(pv[1:2])))
	Tr <- createTransition(pv)
	for(th in 2:6) 
	{
		PI <- pathInc(Tr, origin, ssrSP, type=c("divergent","joint"), theta = theta[th])
		div <- PI$divergent
		joint <- PI$joint
		dataGenGeo <- as.data.frame(cbind(joint, div, geoDist))
		write.csv(dataGenGeo,paste("dataGenGeoT", LETTERS[i], "theta=", theta[th], sep=""))
	}
}

resultR2 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultSign1 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultSign2 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultCoeff1 <- matrix(nrow=length(theta),ncol=length(selectSol))
resultCoeff2 <- matrix(nrow=length(theta),ncol=length(selectSol))

for(i in 1:length(selectSol))
{
	for(th in 1:length(theta))
	{
		dataGG <- read.csv(paste("dataGenGeoT", LETTERS[i], "theta=", theta[th], sep=""))
		dataGG <- as.data.frame(cbind(ssrDist,dataGG))
		result <- permReg(ssrDist ~ joint + div, dat=dataGG, perms = 999)
		resultR2[th,i] <- result$r.square
		resultSign1[th,i] <- result$significance.terms[1]
		resultSign2[th,i] <- result$significance.terms[2]
		resultCoeff1[th,i] <- result$coeff[2]
		resultCoeff2[th,i] <- result$coeff[3]		
	}
}

#Table 2
resultR2 <- round(resultR2, digits=3)
rownames(resultR2) <- theta
colnames(resultR2) <- LETTERS[1:9]

#############################    END ANALYSIS  #
```

